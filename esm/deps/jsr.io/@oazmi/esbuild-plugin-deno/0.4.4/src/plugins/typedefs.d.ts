import type { esbuild, MaybePromise } from "../deps.js";
import type { ImportMap } from "../importmap/typedefs.js";
import type { WorkspacePackage } from "../packageman/base.js";
/** a central enum containing the list of esbuild namespaces used by the plugins in this library. */
export declare const enum PLUGIN_NAMESPACE {
    RESOLVER_PIPELINE = "oazmi-resolver-pipeline",
    LOADER_HTTP = "oazmi-loader-http"
}
/** a list of default namespaces that esbuild uses for native/entry-point resolution. */
export declare const defaultEsbuildNamespaces: (string | undefined)[];
/** a list of all esbuild content type loaders. */
export declare const allEsbuildLoaders: Array<EsbuildLoaderType>;
/** an enum that represents special directories.
 *
 * currently, it is only being used in {@link NpmPluginSetupConfig.nodeModulesDirs}, and {@link NpmAutoInstallCliConfig.dir}.
*/
export declare const enum DIRECTORY {
    /** represents your js-runtime's current working directory (acquired via {@link defaultGetCwd}). */
    CWD = 0,
    /** represents the `absWorkingDir` option provided to your esbuild build config.
     *
     * note that in almost all cases, if esbuild's `absWorkingDir` option was not specified,
     * then we fallback to the current working director (i.e. {@link DIRECTORY.CWD}).
     * this includes the node package scanner function `validResolveDirFinder`
     * (generated by {@link findResolveDirOfNpmPackageFactory}), inside of the npm-plugin ({@link npmPluginSetup}).
    */
    ABS_WORKING_DIR = 1
}
/** this is the common plugin data utilized by the resolvers in {@link resolverPlugin} esbuild-plugin. */
export interface CommonPluginData {
    /** specifies the current scope's import-map aliases.
     * the keys of this object hold the aliased name of the import, while the values hold the absolute path of the referenced resource.
     *
     * for further reading on import maps, see {@link ImportMap}.
    */
    importMap?: ImportMap;
    /** specifies the current scope's runtime package manager (such as deno, jsr, npm, node, etc...),
     * so that the package's own import and export aliases can be resolved appropriately.
    */
    runtimePackage?: WorkspacePackage<any>;
    /** you may control which resolvers to disable through the use of this property. */
    resolverConfig?: {
        /** enable or disable missing `pluginData` inheritance (performed by the {@link entryPlugin}) for the current entity.
         *
         * setting this to `false` will make the inheritance injector **not** record this entity's `pluginData`.
         * thus, in effect, all of the current entity's dependencies will not be able to inherit this entity's `pluginData`,
         * even when they (the dependencies) are lacking one (i.e. `dependency_args.pluginData === undefined`).
         *
         * this _could_ be useful when switching the scope to a new, isolated, package.
         * but you could also strip away the plugin data in the current entity so that its dependencies don't pick up anything.
         * so, the only scenario where this could be useful is when:
         * - you've got a custom loader, which requires some `pluginData` specific to the current entity.
         * - but your loader also returns `puginData: undefined`, making its dependencies acquire `dependency_args.puginData === undefined`.
         * - however, you **don't** want `dependency_args.puginData` to now inherit from `args.pluginData` (the importer's plugin data).
         * - thus, to solve this issue, you make sure that the importer's `args.pluginData` is never recorded by the inheritance resolver.
         *   so, you achieve that by setting `args.pluginData.resolverConfig.useInheritPluginData` to `false`.
         *
         * @defaultValue `true` (enabled)
        */
        useInheritPluginData?: boolean;
        /** enable or disable import-map resolution for the current entity.
         *
         * @defaultValue `true` (enabled)
        */
        useImportMap?: boolean;
        /** enable or disable runtime-package resolution (such as "deno.json") for the current entity.
         *
         * @defaultValue `true` (enabled)
        */
        useRuntimePackage?: boolean;
        /** enable or disable `node_modules` file resolution for the current entity.
         *
         * @defaultValue `true` (enabled)
        */
        useNodeModules?: boolean;
        /** enable or disable relative-path to absolute-path resolution for the current entity.
         *
         * @defaultValue `true` (enabled)
        */
        useRelativePath?: boolean;
    };
    [capture_marker: symbol]: boolean;
}
/** type alias for `esbuild.OnResolveArgs`, slightly tweaked for this library's internal use. */
export type OnResolveArgs = Omit<esbuild.OnResolveArgs, "pluginData"> & {
    pluginData?: CommonPluginData;
};
/** type alias for `esbuild.OnLoadArgs`, slightly tweaked for this library's internal use. */
export type OnLoadArgs = Omit<esbuild.OnLoadArgs, "pluginData"> & {
    pluginData?: CommonPluginData;
};
/** type alias for `esbuild.OnResolveResult`. */
export type OnResolveResult = esbuild.OnResolveResult;
/** type alias for `esbuild.OnLoadResult`. */
export type OnLoadResult = esbuild.OnLoadResult;
/** type alias for the callback function provided to `onResolve` the function (aka `esbuild.PluginBuild["onResolve"]`). */
export type OnResolveCallback = (args: OnResolveArgs) => MaybePromise<OnResolveResult | null | undefined>;
/** type alias for the callback function provided to `OnLoadCallback` the function (aka `esbuild.PluginBuild["OnLoadCallback"]`). */
export type OnLoadCallback = (args: OnLoadArgs) => MaybePromise<OnLoadResult | null | undefined>;
/** type alias for `esbuild.Plugin`. */
export type EsbuildPlugin = esbuild.Plugin;
/** type alias for `esbuild.Plugin["setup"]`. */
export type EsbuildPluginSetup = esbuild.Plugin["setup"];
/** type alias for `esbuild.PluginBuild`. */
export type EsbuildPluginBuild = esbuild.PluginBuild;
/** type alias for `esbuild.Loader`. */
export type EsbuildLoaderType = esbuild.Loader;
/** a logging function that can be used as an alternative to the default `console.log` logger function. */
export type LoggerFunction = (...data: any[]) => void;
/** these are the various formats of input and output specification accepted by esbuild for a single entity. */
export type EsbuildEntryPointType = string | {
    in: string;
    out: string;
} | [input: string, output: string];
/** these are the various formats of entry points accepted by esbuild. */
export type EsbuildEntryPointsType = ImportMap | Array<EsbuildEntryPointType>;
//# sourceMappingURL=typedefs.d.ts.map